<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF XFA Compiler Universale - Auto-Discovery</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        .log-area {
            background: #000;
            color: #00ff00;
            font-family: monospace;
            padding: 15px;
            border-radius: 8px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
        }
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }
        .btn:disabled {
            background: #ccc !important;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .btn-blue { background: #3b82f6; color: white; }
        .btn-green { background: #10b981; color: white; }
        .btn-purple { background: #8b5cf6; color: white; }
        .btn-red { background: #ef4444; color: white; }
        .btn-orange { background: #f97316; color: white; }
        .btn-yellow { background: #eab308; color: white; }
        .status-ok { color: #10b981; }
        .status-error { color: #ef4444; }
        .status-pending { color: #eab308; }
        .progress-bar {
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s ease;
        }
        .step-indicator {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
        }
        .step {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            margin: 0 4px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }
        .step.completed { background: #10b981; color: white; }
        .step.active { background: #3b82f6; color: white; animation: pulse 2s infinite; }
        .step.pending { background: #e5e7eb; color: #6b7280; }
        .mapping-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr auto;
            gap: 12px;
            align-items: center;
            padding: 8px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            margin-bottom: 8px;
        }
        .mapping-row.mapped { background: #f0fdf4; border-color: #10b981; }
        .mapping-row.unmapped { background: #fef2f2; border-color: #ef4444; }
        .drag-over { background: #dbeafe; border-color: #3b82f6; }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="container mx-auto p-6 max-w-7xl">
        <!-- Header -->
        <div class="bg-gradient-to-r from-purple-600 to-blue-600 text-white p-6 rounded-lg mb-6 text-center">
            <h1 class="text-3xl font-bold mb-2">üîç PDF XFA Compiler Universale</h1>
            <p class="opacity-90">Auto-Discovery ‚Ä¢ Multi-Tabella ‚Ä¢ Mapping Dinamico ‚Ä¢ Zero Configurazione</p>
        </div>

        <!-- Step Indicator -->
        <div class="step-indicator">
            <div id="step1" class="step active">1. Carica PDF</div>
            <div id="step2" class="step pending">2. Auto-Discovery</div>
            <div id="step3" class="step pending">3. Carica CSV</div>
            <div id="step4" class="step pending">4. Mapping</div>
            <div id="step5" class="step pending">5. Compila</div>
        </div>

        <!-- API Configuration -->
        <div class="bg-white p-6 rounded-lg shadow mb-6">
            <h2 class="text-xl font-bold mb-4 text-blue-700">üîë Configurazione API</h2>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div>
                    <label class="block text-sm font-bold mb-2">API Key pdfRest:</label>
                    <div class="flex space-x-2">
                        <input 
                            type="password" 
                            id="apiKeyInput" 
                            placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
                            class="flex-1 p-3 border rounded font-mono text-sm"
                            value="bc95f9dc-d3e0-4b30-8da0-53f6deb83712"
                        >
                        <button id="toggleKeyBtn" class="btn btn-blue px-3">üëÅÔ∏è</button>
                    </div>
                    <div id="apiStatus" class="mt-2 text-sm status-ok">‚úÖ API Key preconfigurata</div>
                </div>
                <div class="flex flex-col justify-end">
                    <button id="saveApiBtn" class="btn btn-green mb-2">üíæ Salva API Key</button>
                </div>
            </div>
        </div>

        <!-- Step 1: PDF Upload -->
        <div id="pdfUploadSection" class="bg-white p-6 rounded-lg shadow mb-6">
            <h2 class="text-xl font-bold mb-4 text-purple-700">üìÑ Step 1: Carica PDF XFA</h2>
            <div class="border-2 border-dashed border-purple-400 rounded-lg p-8 text-center">
                <div class="text-6xl mb-4">üìÑ</div>
                <h3 class="text-lg font-bold mb-2">Carica il tuo PDF XFA</h3>
                <p class="text-gray-600 mb-4">Il sistema analizzer√† automaticamente la struttura e identificher√† tutte le tabelle</p>
                <input type="file" id="pdfFileInput" accept=".pdf" class="hidden">
                <button id="selectPDFBtn" class="btn btn-purple text-lg px-8 py-4">üìÇ Seleziona PDF XFA</button>
                <div id="pdfStatus" class="mt-4 text-sm"></div>
            </div>
        </div>

        <!-- Step 2: Auto-Discovery Results -->
        <div id="discoverySection" class="bg-white p-6 rounded-lg shadow mb-6 hidden">
            <h2 class="text-xl font-bold mb-4 text-blue-700">üîç Step 2: Struttura Rilevata</h2>
            <div id="discoveryResults"></div>
            <div class="mt-6 text-center">
                <button id="proceedToCSVBtn" class="btn btn-blue text-lg px-8 py-4" disabled>
                    ‚û°Ô∏è Procedi al Caricamento CSV
                </button>
            </div>
        </div>

        <!-- Step 3: CSV Upload per Table -->
        <div id="csvUploadSection" class="bg-white p-6 rounded-lg shadow mb-6 hidden">
            <h2 class="text-xl font-bold mb-4 text-green-700">üìä Step 3: Carica CSV per Tabella</h2>
            <div id="csvUploadTables"></div>
            <div class="mt-6 text-center">
                <button id="proceedToMappingBtn" class="btn btn-green text-lg px-8 py-4" disabled>
                    ‚û°Ô∏è Procedi al Mapping
                </button>
            </div>
        </div>

        <!-- Step 4: Dynamic Mapping -->
        <div id="mappingSection" class="bg-white p-6 rounded-lg shadow mb-6 hidden">
            <h2 class="text-xl font-bold mb-4 text-yellow-600">üîó Step 4: Mapping Colonne</h2>
            <div id="mappingTables"></div>
            <div class="mt-6 text-center">
                <button id="proceedToCompileBtn" class="btn btn-yellow text-lg px-8 py-4" disabled>
                    ‚û°Ô∏è Procedi alla Compilazione
                </button>
            </div>
        </div>

        <!-- Step 5: Compilation -->
        <div id="compilationSection" class="bg-white p-6 rounded-lg shadow mb-6 hidden">
            <h2 class="text-xl font-bold mb-4 text-orange-600">üöÄ Step 5: Compilazione Multi-Tabella</h2>
            
            <!-- Summary -->
            <div id="compilationSummary" class="bg-gray-50 p-4 rounded-lg mb-6"></div>
            
            <!-- Progress -->
            <div id="processProgress" class="hidden mb-4">
                <div class="progress-bar mb-2">
                    <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                </div>
                <div class="flex justify-between items-center">
                    <div id="progressText" class="text-sm">Preparazione...</div>
                    <div id="progressTime" class="text-xs text-gray-500">0s</div>
                </div>
                <div id="progressDetails" class="text-xs text-gray-600 mt-1"></div>
            </div>
            
            <!-- Actions -->
            <div class="text-center space-x-4">
                <button id="compileBtn" class="btn btn-orange text-lg px-8 py-4" disabled>
                    üöÄ COMPILA PDF SELETTIVO
                </button>
                <button id="resetBtn" class="btn btn-red">üîÑ Ricomincia</button>
            </div>
        </div>

        <!-- Results -->
        <div id="resultsSection" class="bg-white p-6 rounded-lg shadow mb-6 hidden">
            <h2 class="text-xl font-bold mb-4 text-green-700">‚úÖ Risultato Compilazione</h2>
            <div id="resultsContent"></div>
        </div>

        <!-- Log -->
        <div class="bg-white p-6 rounded-lg shadow">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-700">üìã Log Operazioni</h2>
                <button id="clearLogBtn" class="btn btn-red text-sm">üóëÔ∏è Pulisci</button>
            </div>
            <div id="logArea" class="log-area"></div>
        </div>
    </div>

    <script>
        // =============================================
        // GLOBAL STATE - Enhanced for Multi-Table
        // =============================================
        const state = {
            apiKey: 'bc95f9dc-d3e0-4b30-8da0-53f6deb83712',
            currentStep: 1,
            pdfFile: null,
            pdfResourceId: null,
            pdfStructure: null,
            discoveredTables: [],
            csvData: {}, // { tableId: csvRecords }
            mappings: {}, // { tableId: { csvField: xfaField } }
            compiledPdfUrl: null,
            processingStartTime: null,
            fallbackMode: false
        };

        const API_BASE = '/api';

        // =============================================
        // LOGGING SYSTEM
        // =============================================
        function log(message, type = 'info') {
            const now = new Date().toLocaleTimeString();
            const colors = {
                'info': '#00ff00',
                'warn': '#ffff00', 
                'error': '#ff0000',
                'success': '#00ffff',
                'api': '#ff69b4',
                'discovery': '#9333ea'
            };
            const logArea = document.getElementById('logArea');
            const color = colors[type] || '#00ff00';
            
            logArea.innerHTML += `<div style="color: ${color};">[${now}] ${message}</div>`;
            logArea.scrollTop = logArea.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function updateProgress(percent, text, details = '') {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
            
            if (state.processingStartTime) {
                const elapsed = Math.round((Date.now() - state.processingStartTime) / 1000);
                document.getElementById('progressTime').textContent = `${elapsed}s`;
            }
            
            if (details) {
                document.getElementById('progressDetails').textContent = details;
            }
        }

        // =============================================
        // STEP MANAGEMENT
        // =============================================
        function updateStepIndicator(currentStep) {
            state.currentStep = currentStep;
            
            for (let i = 1; i <= 5; i++) {
                const stepEl = document.getElementById(`step${i}`);
                stepEl.className = 'step ' + 
                    (i < currentStep ? 'completed' : 
                     i === currentStep ? 'active' : 'pending');
            }
        }

        function showSection(sectionId) {
            // Hide all sections
            ['pdfUploadSection', 'discoverySection', 'csvUploadSection', 
             'mappingSection', 'compilationSection', 'resultsSection'].forEach(id => {
                document.getElementById(id).classList.add('hidden');
            });
            
            // Show target section
            document.getElementById(sectionId).classList.remove('hidden');
        }

        // =============================================
        // PDF UPLOAD & ANALYSIS
        // =============================================
        document.getElementById('selectPDFBtn').addEventListener('click', () => {
            document.getElementById('pdfFileInput').click();
        });

        document.getElementById('pdfFileInput').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.type !== 'application/pdf') {
                log('‚ùå Il file deve essere un PDF', 'error');
                return;
            }
            
            state.pdfFile = file;
            state.pdfResourceId = null;
            const sizeMB = (file.size / 1024 / 1024).toFixed(2);
            
            log(`üìÑ PDF selezionato: ${file.name} (${sizeMB} MB)`, 'success');
            document.getElementById('pdfStatus').innerHTML = `<span class="status-ok">‚úÖ ${file.name}</span>`;
            
            // Auto-start discovery
            await startPDFDiscovery();
        });

        async function startPDFDiscovery() {
            log('üîç AVVIO AUTO-DISCOVERY...', 'discovery');
            updateStepIndicator(2);
            
            try {
                // Step 1: Upload PDF
                log('üì§ Upload PDF per analisi...', 'api');
                await uploadPDF();
                
                // Step 2: Get PDF Info
                log('üìã Analisi struttura PDF...', 'api');
                await analyzePDFStructure();
                
                // Step 3: Extract Form Structure
                log('üîç Estrazione struttura XFA...', 'api');
                await extractFormStructure();
                
                // Step 4: Parse Structure & Identify Tables
                log('üèóÔ∏è Identificazione tabelle...', 'discovery');
                parseXFAStructure();
                
                // Show results
                displayDiscoveryResults();
                showSection('discoverySection');
                updateStepIndicator(3);
                
            } catch (error) {
                log(`‚ùå Errore durante discovery: ${error.message}`, 'error');
            }
        }

        async function uploadPDF() {
            const formData = new FormData();
            formData.append('file', state.pdfFile);
            
            const response = await fetch(`${API_BASE}/upload`, {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Upload fallito: ${text}`);
            }
            
            const data = await response.json();
            state.pdfResourceId = data.files[0].id;
            log(`‚úÖ PDF uploadato. ID: ${state.pdfResourceId}`, 'success');
        }

        async function analyzePDFStructure() {
            const form = new FormData();
            form.append('id', state.pdfResourceId);
            form.append('queries', 'contains_xfa,contains_acroforms,page_count,filename');

            const response = await fetch(`${API_BASE}/pdf-info`, {
                method: 'POST',
                body: form
            });

            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Analisi fallita: ${text}`);
            }

            const data = await response.json();
            const isXFA = String(data.contains_xfa).toLowerCase().includes('tr');
            
            if (!isXFA) {
                throw new Error('PDF non contiene moduli XFA. Questo tool supporta solo PDF XFA.');
            }
            
            log('‚úÖ PDF XFA confermato - Struttura auto-espandibile rilevata', 'success');
            log(`üìÑ Pagine: ${data.page_count} | File: ${data.filename}`, 'info');
        }

        async function extractFormStructure() {
            const form = new FormData();
            form.append('id', state.pdfResourceId);
            form.append('data_format', 'xml');
            form.append('output', 'struttura_discovery');

            const response = await fetch(`${API_BASE}/exported-form-data`, {
                method: 'POST',
                body: form
            });

            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Estrazione struttura fallita: ${text}`);
            }

            const data = await response.json();
            
            // Download XML structure
            const xmlResponse = await fetch(data.outputUrl);
            const xmlText = await xmlResponse.text();
            
            state.pdfStructure = xmlText;
            log('‚úÖ Struttura XFA estratta con successo', 'success');
        }

        // =============================================
        // XFA STRUCTURE PARSING
        // =============================================
        function parseXFAStructure() {
            log('üîç Parsing struttura XFA per identificare tabelle...', 'discovery');
            
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(state.pdfStructure, 'text/xml');
                
                // Find repeating elements (tables)
                const tables = findRepeatableTables(xmlDoc);
                state.discoveredTables = tables;
                
                log(`‚úÖ Discovery completata: ${tables.length} tabelle identificate`, 'success');
                
            } catch (error) {
                log(`‚ùå Errore parsing XFA: ${error.message}`, 'error');
                throw error;
            }
        }

        function findRepeatableTables(xmlDoc) {
            const tables = [];
            const rootElements = xmlDoc.documentElement.children;
            
            // Analizza tutti gli elementi di primo livello
            for (let i = 0; i < rootElements.length; i++) {
                const element = rootElements[i];
                
                // Skip elementi non significativi
                if (element.tagName === 'datasets' || element.tagName === 'template') {
                    continue;
                }
                
                // Elementi che potrebbero essere tabelle
                if (element.children.length > 3) { // Soglia minima campi
                    const fields = extractFieldsFromElement(element);
                    
                    if (fields.length > 0) {
                        tables.push({
                            id: element.tagName,
                            name: formatTableName(element.tagName),
                            fields: fields,
                            elementPath: element.tagName,
                            estimatedRecords: estimateRecordCapacity(element)
                        });
                        
                        log(`üè∑Ô∏è Tabella rilevata: ${element.tagName} (${fields.length} campi)`, 'discovery');
                    }
                }
            }
            
            // Se non troviamo tabelle standard, cerca pattern alternativi
            if (tables.length === 0) {
                log('‚ö†Ô∏è Nessuna tabella standard trovata, ricerca pattern alternativi...', 'warn');
                return findAlternativePatterns(xmlDoc);
            }
            
            return tables;
        }

        function extractFieldsFromElement(element) {
            const fields = [];
            
            for (let i = 0; i < element.children.length; i++) {
                const child = element.children[i];
                
                // Solo elementi leaf (senza figli)
                if (child.children.length === 0 && child.textContent.trim() !== '') {
                    fields.push({
                        name: child.tagName,
                        displayName: formatFieldName(child.tagName),
                        value: child.textContent.trim(),
                        type: inferFieldType(child.textContent)
                    });
                }
            }
            
            return fields;
        }

        function formatTableName(tagName) {
            return tagName
                .replace(/_/g, ' ')
                .replace(/([A-Z])/g, ' $1')
                .trim()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function formatFieldName(fieldName) {
            return fieldName
                .replace(/_/g, ' ')
                .replace(/([A-Z])/g, ' $1')
                .trim()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function inferFieldType(value) {
            if (!value) return 'text';
            if (!isNaN(value) && !isNaN(parseFloat(value))) return 'number';
            if (value.match(/^\d{4}-\d{2}-\d{2}$/)) return 'date';
            if (value.match(/^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/)) return 'email';
            return 'text';
        }

        function estimateRecordCapacity(element) {
            // Logica euristica per stimare quanti record pu√≤ contenere
            const fieldCount = element.children.length;
            if (fieldCount > 10) return '100+';
            if (fieldCount > 5) return '50+';
            return '20+';
        }

        function findAlternativePatterns(xmlDoc) {
            // Fallback: cerca pattern pi√π generici
            const tables = [];
            
            // Pattern 1: Elementi con molti figli
            const allElements = xmlDoc.getElementsByTagName('*');
            for (let element of allElements) {
                if (element.children.length >= 5) {
                    const fields = extractFieldsFromElement(element);
                    if (fields.length >= 3) {
                        tables.push({
                            id: element.tagName || 'generic_table',
                            name: formatTableName(element.tagName || 'Tabella Generica'),
                            fields: fields,
                            elementPath: element.tagName,
                            estimatedRecords: '10+'
                        });
                    }
                }
            }
            
            return tables;
        }

        // =============================================
        // DISCOVERY RESULTS DISPLAY
        // =============================================
        function displayDiscoveryResults() {
            const container = document.getElementById('discoveryResults');
            
            if (state.discoveredTables.length === 0) {
                container.innerHTML = `
                    <div class="bg-yellow-50 border border-yellow-200 p-6 rounded-lg text-center">
                        <div class="text-4xl mb-4">‚ö†Ô∏è</div>
                        <h3 class="text-lg font-bold text-yellow-700 mb-2">Nessuna Tabella Rilevata</h3>
                        <p class="text-yellow-800">Il PDF non sembra contenere tabelle strutturate identificabili automaticamente.</p>
                        <button id="manualModeBtn" class="btn btn-yellow mt-4">üîß Modalit√† Manuale</button>
                    </div>
                `;
                return;
            }
            
            let html = `
                <div class="bg-blue-50 border border-blue-200 p-4 rounded-lg mb-6">
                    <h3 class="font-bold text-blue-700 mb-2">üéâ Auto-Discovery Completata!</h3>
                    <p class="text-blue-800">Trovate <strong>${state.discoveredTables.length}</strong> tabelle nel PDF. 
                    Ora puoi caricare un CSV per ogni tabella.</p>
                </div>
                
                <div class="grid gap-4">
            `;
            
            state.discoveredTables.forEach((table, index) => {
                html += `
                    <div class="border border-gray-200 rounded-lg p-4">
                        <div class="flex justify-between items-start mb-3">
                            <div>
                                <h4 class="text-lg font-bold text-gray-800">${table.name}</h4>
                                <p class="text-sm text-gray-600">
                                    ID: <code class="bg-gray-100 px-2 py-1 rounded">${table.id}</code> | 
                                    Campi: <strong>${table.fields.length}</strong> | 
                                    Capacit√†: <strong>${table.estimatedRecords}</strong> record
                                </p>
                            </div>
                            <span class="bg-purple-100 text-purple-700 px-3 py-1 rounded-full text-sm font-bold">
                                Tabella ${index + 1}
                            </span>
                        </div>
                        
                        <div class="bg-gray-50 p-3 rounded max-h-32 overflow-y-auto">
                            <h5 class="font-bold text-sm mb-2">Campi rilevati:</h5>
                            <div class="grid grid-cols-2 md:grid-cols-3 gap-2 text-xs">
                `;
                
                table.fields.forEach(field => {
                    const typeColor = field.type === 'number' ? 'bg-blue-100 text-blue-700' :
                                     field.type === 'date' ? 'bg-green-100 text-green-700' :
                                     'bg-gray-100 text-gray-700';
                    
                    html += `
                        <div class="flex items-center space-x-1">
                            <span class="${typeColor} px-2 py-1 rounded text-xs">${field.type}</span>
                            <span class="truncate">${field.displayName}</span>
                        </div>
                    `;
                });
                
                html += `
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
            
            // Enable proceed button
            document.getElementById('proceedToCSVBtn').disabled = false;
        }

        // =============================================
        // CSV UPLOAD SECTION
        // =============================================
        document.getElementById('proceedToCSVBtn').addEventListener('click', () => {
            showSection('csvUploadSection');
            updateStepIndicator(3);
            setupCSVUpload();
        });

        function setupCSVUpload() {
            const container = document.getElementById('csvUploadTables');
            
            let html = `
                <div class="bg-green-50 border border-green-200 p-4 rounded-lg mb-6">
                    <h3 class="font-bold text-green-700 mb-2">üìä Caricamento CSV (Opzionale per Tabella)</h3>
                    <p class="text-green-800">
                        <strong>‚ú® Novit√†:</strong> Non √® necessario caricare un CSV per ogni tabella! 
                        Carica solo i CSV per le tabelle che vuoi compilare nel PDF finale.
                    </p>
                    <div class="mt-3 p-3 bg-blue-50 border border-blue-200 rounded">
                        <p class="text-sm text-blue-800">
                            <strong>üí° Come funziona:</strong><br>
                            ‚Ä¢ <strong>Almeno 1 CSV</strong> richiesto per procedere<br>
                            ‚Ä¢ <strong>CSV mancanti</strong> = tabelle ignorate nel risultato<br>
                            ‚Ä¢ <strong>Pi√π CSV</strong> = compilazione multi-tabella completa
                        </p>
                    </div>
                </div>
                
                <div class="grid gap-6">
            `;
            
            state.discoveredTables.forEach((table, index) => {
                html += `
                    <div class="border border-gray-200 rounded-lg p-6">
                        <div class="flex justify-between items-center mb-4">
                            <div>
                                <h4 class="text-lg font-bold">${table.name}</h4>
                                <p class="text-sm text-gray-500">
                                    <span class="bg-blue-100 text-blue-700 px-2 py-1 rounded text-xs font-bold">OPZIONALE</span>
                                    ‚Ä¢ ${table.fields.length} campi ‚Ä¢ Capacit√†: ${table.estimatedRecords}
                                </p>
                            </div>
                            <span id="csvStatus_${table.id}" class="text-sm status-pending">‚ö™ Opzionale</span>
                        </div>
                        
                        <div class="border-2 border-dashed border-green-300 rounded-lg p-6 text-center">
                            <div class="text-3xl mb-2">üìä</div>
                            <p class="text-sm text-gray-600 mb-1">CSV per <strong>${table.name}</strong></p>
                            <p class="text-xs text-gray-500 mb-3">‚ö™ Carica solo se vuoi compilare questa tabella</p>
                            <input type="file" id="csvInput_${table.id}" accept=".csv" class="hidden">
                            <button onclick="document.getElementById('csvInput_${table.id}').click()" 
                                    class="btn btn-green">
                                üìÇ Carica CSV (Opzionale)
                            </button>
                        </div>
                        
                        <div id="csvPreview_${table.id}" class="hidden mt-4 bg-gray-50 p-3 rounded">
                            <!-- CSV preview will be inserted here -->
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
            
            // Setup event listeners for CSV uploads
            state.discoveredTables.forEach(table => {
                document.getElementById(`csvInput_${table.id}`).addEventListener('change', (event) => {
                    handleCSVUpload(event, table.id);
                });
            });
        }

        function handleCSVUpload(event, tableId) {
            const file = event.target.files[0];
            if (!file) return;
            
            log(`üìä Caricamento CSV per tabella: ${tableId}`, 'info');
            
            const reader = new FileReader();
            reader.onload = (e) => {
                Papa.parse(e.target.result, {
                    header: true,
                    delimiter: ";",
                    skipEmptyLines: true,
                    complete: (results) => {
                        // Filter out empty rows
                        const cleanData = results.data.filter(row => {
                            return Object.values(row).some(value => value && value.trim());
                        });
                        
                        state.csvData[tableId] = cleanData;
                        const recordCount = cleanData.length;
                        
                        log(`‚úÖ CSV caricato per ${tableId}: ${recordCount} record`, 'success');
                        
                        // Update status
                        document.getElementById(`csvStatus_${tableId}`).innerHTML = 
                            `<span class="status-ok">‚úÖ ${recordCount} record caricati</span>`;
                        
                        // Show preview
                        showCSVPreview(tableId, cleanData);
                        
                        // Check if at least one CSV is loaded
                        checkAtLeastOneCSVLoaded();
                    },
                    error: (error) => {
                        log(`‚ùå Errore parsing CSV ${tableId}: ${error.message}`, 'error');
                    }
                });
            };
            reader.readAsText(file, 'UTF-8');
        }

        function showCSVPreview(tableId, data) {
            const preview = document.getElementById(`csvPreview_${tableId}`);
            
            if (data.length === 0) {
                preview.innerHTML = '<p class="text-red-600">Nessun record trovato nel CSV</p>';
                preview.classList.remove('hidden');
                return;
            }
            
            const headers = Object.keys(data[0]);
            
            let html = `
                <h5 class="font-bold text-sm mb-2">Anteprima CSV (primi 3 record):</h5>
                <div class="overflow-x-auto">
                    <table class="w-full text-xs border-collapse border border-gray-300">
                        <thead>
                            <tr class="bg-gray-200">
            `;
            
            headers.forEach(header => {
                html += `<th class="border border-gray-300 p-2 text-left">${header}</th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            data.slice(0, 3).forEach(row => {
                html += '<tr>';
                headers.forEach(header => {
                    const value = row[header] || '';
                    html += `<td class="border border-gray-300 p-2">${value.length > 20 ? value.substring(0, 20) + '...' : value}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            if (data.length > 3) {
                html += `<p class="text-center mt-2 text-gray-500 text-xs">... e altri ${data.length - 3} record</p>`;
            }
            
            html += '</div>';
            preview.innerHTML = html;
            preview.classList.remove('hidden');
        }

        function checkAtLeastOneCSVLoaded() {
            const loadedTables = state.discoveredTables.filter(table => 
                state.csvData[table.id] && state.csvData[table.id].length > 0
            );
            
            const hasAtLeastOne = loadedTables.length > 0;
            
            if (hasAtLeastOne) {
                document.getElementById('proceedToMappingBtn').disabled = false;
                log(`‚úÖ CSV caricati per ${loadedTables.length}/${state.discoveredTables.length} tabelle`, 'success');
                log(`üìä Tabelle da processare: ${loadedTables.map(t => t.name).join(', ')}`, 'info');
                log(`‚ö™ Tabelle ignorate: ${state.discoveredTables.filter(t => !state.csvData[t.id]).length}`, 'info');
            } else {
                document.getElementById('proceedToMappingBtn').disabled = true;
                log(`‚ö†Ô∏è Carica almeno un CSV per procedere`, 'warn');
            }
        }

        // =============================================
        // MAPPING SECTION
        // =============================================
        document.getElementById('proceedToMappingBtn').addEventListener('click', () => {
            showSection('mappingSection');
            updateStepIndicator(4);
            setupMappingInterface();
        });

        function setupMappingInterface() {
            const container = document.getElementById('mappingTables');
            
            // ‚úÖ NOVIT√Ä: Filtra solo tabelle con CSV caricati
            const tablesWithCSV = state.discoveredTables.filter(table => 
                state.csvData[table.id] && state.csvData[table.id].length > 0
            );
            
            let html = `
                <div class="bg-yellow-50 border border-yellow-200 p-4 rounded-lg mb-6">
                    <h3 class="font-bold text-yellow-700 mb-2">üîó Mapping Intelligente</h3>
                    <p class="text-yellow-800">
                        Il sistema propone automaticamente abbinamenti per le <strong>${tablesWithCSV.length}</strong> 
                        tabelle con CSV caricati. Le tabelle senza CSV saranno ignorate nella compilazione.
                    </p>
                </div>
            `;
            
            if (tablesWithCSV.length === 0) {
                html += `
                    <div class="bg-red-50 border border-red-200 p-6 rounded-lg text-center">
                        <div class="text-4xl mb-4">‚ö†Ô∏è</div>
                        <h3 class="text-lg font-bold text-red-700 mb-2">Nessun CSV Caricato</h3>
                        <p class="text-red-800">Torna indietro e carica almeno un CSV per procedere.</p>
                    </div>
                `;
                container.innerHTML = html;
                return;
            }
            
            tablesWithCSV.forEach(table => {
                const csvHeaders = Object.keys(state.csvData[table.id][0] || {});
                const autoMapping = generateAutoMapping(csvHeaders, table.fields);
                state.mappings[table.id] = autoMapping;
                
                const recordCount = state.csvData[table.id].length;
                
                html += `
                    <div class="border border-gray-200 rounded-lg p-6 mb-6">
                        <div class="flex justify-between items-center mb-4">
                            <div>
                                <h4 class="text-lg font-bold">${table.name}</h4>
                                <p class="text-sm text-green-600">
                                    ‚úÖ <strong>${recordCount}</strong> record caricati ‚Ä¢ Mapping attivo
                                </p>
                            </div>
                            <span class="bg-green-100 text-green-700 px-3 py-1 rounded-full text-sm font-bold">
                                ATTIVA
                            </span>
                        </div>
                        <div class="grid gap-3" id="mapping_${table.id}">
                `;
                
                csvHeaders.forEach(csvHeader => {
                    const mappedField = autoMapping[csvHeader];
                    const isMatched = mappedField !== null;
                    
                    html += `
                        <div class="mapping-row ${isMatched ? 'mapped' : 'unmapped'}">
                            <div class="font-mono text-sm bg-blue-50 p-2 rounded">
                                ${csvHeader}
                            </div>
                            <div class="text-gray-400">‚Üí</div>
                            <div>
                                <select class="w-full p-2 border rounded mapping-select" 
                                        data-table="${table.id}" data-csv-field="${csvHeader}">
                                    <option value="">-- Non mappato --</option>
                    `;
                    
                    table.fields.forEach(field => {
                        const selected = mappedField === field.name ? 'selected' : '';
                        html += `<option value="${field.name}" ${selected}>${field.displayName}</option>`;
                    });
                    
                    html += `
                                </select>
                            </div>
                            <div class="text-sm text-gray-500">
                                ${isMatched ? '‚úÖ Auto-mappato' : '‚ö†Ô∏è Non mappato'}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            // ‚úÖ RIEPILOGO: Mostra tabelle ignorate
            const ignoredTables = state.discoveredTables.filter(table => 
                !state.csvData[table.id] || state.csvData[table.id].length === 0
            );
            
            if (ignoredTables.length > 0) {
                html += `
                    <div class="bg-gray-50 border border-gray-200 p-4 rounded-lg">
                        <h4 class="font-bold text-gray-700 mb-2">‚ö™ Tabelle Ignorate (${ignoredTables.length})</h4>
                        <p class="text-sm text-gray-600 mb-2">
                            Queste tabelle non saranno incluse nella compilazione finale:
                        </p>
                        <div class="flex flex-wrap gap-2">
                            ${ignoredTables.map(table => 
                                `<span class="bg-gray-200 text-gray-700 px-2 py-1 rounded text-xs">${table.name}</span>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
            
            // Setup event listeners for mapping changes
            document.querySelectorAll('.mapping-select').forEach(select => {
                select.addEventListener('change', handleMappingChange);
            });
            
            // Check initial mapping status
            checkMappingComplete();
        }

        function generateAutoMapping(csvHeaders, pdfFields) {
            const mapping = {};
            
            csvHeaders.forEach(csvHeader => {
                const normalizedCSV = normalizeFieldName(csvHeader);
                let bestMatch = null;
                let bestScore = 0;
                
                pdfFields.forEach(pdfField => {
                    const normalizedPDF = normalizeFieldName(pdfField.displayName);
                    const score = calculateSimilarity(normalizedCSV, normalizedPDF);
                    
                    if (score > bestScore && score > 0.6) { // Threshold 60%
                        bestMatch = pdfField.name;
                        bestScore = score;
                    }
                });
                
                mapping[csvHeader] = bestMatch;
                
                if (bestMatch) {
                    log(`üîó Auto-mapping: ${csvHeader} ‚Üí ${bestMatch} (${Math.round(bestScore * 100)}%)`, 'success');
                }
            });
            
            return mapping;
        }

        function normalizeFieldName(name) {
            return name.toLowerCase()
                      .replace(/[^a-z0-9]/g, '')
                      .replace(/^(n|num|numero)/i, '')
                      .replace(/(sett|settimana)/i, 'settimana')
                      .replace(/(ore|hour)/i, 'ore');
        }

        function calculateSimilarity(str1, str2) {
            // Simple Levenshtein distance implementation
            const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
            
            for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
            
            for (let j = 1; j <= str2.length; j++) {
                for (let i = 1; i <= str1.length; i++) {
                    const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
                    matrix[j][i] = Math.min(
                        matrix[j][i - 1] + 1,
                        matrix[j - 1][i] + 1,
                        matrix[j - 1][i - 1] + indicator
                    );
                }
            }
            
            const distance = matrix[str2.length][str1.length];
            const maxLength = Math.max(str1.length, str2.length);
            return maxLength === 0 ? 1 : (maxLength - distance) / maxLength;
        }

        function handleMappingChange(event) {
            const select = event.target;
            const tableId = select.dataset.table;
            const csvField = select.dataset.csvField;
            const mappedValue = select.value;
            
            // Update mapping
            state.mappings[tableId][csvField] = mappedValue || null;
            
            // Update visual indicator
            const row = select.closest('.mapping-row');
            if (mappedValue) {
                row.className = 'mapping-row mapped';
                row.querySelector('.text-gray-500').textContent = '‚úÖ Mappato';
            } else {
                row.className = 'mapping-row unmapped';
                row.querySelector('.text-gray-500').textContent = '‚ö†Ô∏è Non mappato';
            }
            
            log(`üîó Mapping aggiornato: ${csvField} ‚Üí ${mappedValue || 'non mappato'}`, 'info');
            
            // Check if mapping is complete
            checkMappingComplete();
        }

        function checkMappingComplete() {
            let allComplete = true;
            let totalMapped = 0;
            let totalFields = 0;
            
            // ‚úÖ NOVIT√Ä: Controlla solo tabelle con CSV caricati
            const tablesWithCSV = state.discoveredTables.filter(table => 
                state.csvData[table.id] && state.csvData[table.id].length > 0
            );
            
            tablesWithCSV.forEach(table => {
                const csvHeaders = Object.keys(state.csvData[table.id][0] || {});
                const mapping = state.mappings[table.id] || {};
                
                csvHeaders.forEach(header => {
                    totalFields++;
                    if (mapping[header]) {
                        totalMapped++;
                    }
                });
            });
            
            if (totalFields === 0) {
                allComplete = false;
            } else if (totalMapped < totalFields * 0.3) { // Soglia ridotta al 30%
                allComplete = false;
            }
            
            document.getElementById('proceedToCompileBtn').disabled = !allComplete;
            
            if (allComplete && totalFields > 0) {
                log(`‚úÖ Mapping completato: ${totalMapped}/${totalFields} campi mappati (${tablesWithCSV.length} tabelle attive)`, 'success');
            } else if (totalFields > 0) {
                log(`‚ö†Ô∏è Mapping incompleto: ${totalMapped}/${totalFields} campi mappati (min 30% richiesto)`, 'warn');
            }
        }

        // =============================================
        // COMPILATION SECTION
        // =============================================
        document.getElementById('proceedToCompileBtn').addEventListener('click', () => {
            showSection('compilationSection');
            updateStepIndicator(5);
            setupCompilationSummary();
        });

        function setupCompilationSummary() {
            const container = document.getElementById('compilationSummary');
            
            // ‚úÖ NOVIT√Ä: Solo tabelle con CSV caricati
            const activeTablesRecords = {};
            const ignoredTables = [];
            
            state.discoveredTables.forEach(table => {
                if (state.csvData[table.id] && state.csvData[table.id].length > 0) {
                    activeTablesRecords[table.id] = {
                        name: table.name,
                        records: state.csvData[table.id].length,
                        mappedFields: Object.values(state.mappings[table.id] || {}).filter(v => v).length,
                        totalFields: Object.keys(state.csvData[table.id][0] || {}).length
                    };
                } else {
                    ignoredTables.push(table);
                }
            });
            
            const totalRecords = Object.values(activeTablesRecords).reduce((sum, table) => sum + table.records, 0);
            const activeTableCount = Object.keys(activeTablesRecords).length;
            
            let html = `
                <h3 class="font-bold mb-4">üìä Riepilogo Compilazione Intelligente</h3>
                
                <div class="bg-blue-50 border border-blue-200 p-4 rounded-lg mb-4">
                    <h4 class="font-bold text-blue-700 mb-2">‚ú® Compilazione Selettiva Attiva</h4>
                    <p class="text-sm text-blue-800">
                        Il sistema compiler√† <strong>${activeTableCount}</strong> tabelle su <strong>${state.discoveredTables.length}</strong> 
                        totali rilevate. Le tabelle senza CSV saranno automaticamente ignorate.
                    </p>
                </div>
            `;
            
            if (activeTableCount > 0) {
                html += '<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-4">';
                
                Object.entries(activeTablesRecords).forEach(([tableId, table]) => {
                    html += `
                        <div class="bg-white border border-green-200 rounded-lg p-4 border-l-4 border-l-green-500">
                            <h4 class="font-bold text-gray-800">${table.name}</h4>
                            <div class="text-sm text-gray-600 space-y-1">
                                <div>üìä Record: <strong class="text-green-600">${table.records}</strong></div>
                                <div>üîó Campi mappati: <strong>${table.mappedFields}/${table.totalFields}</strong></div>
                                <div>üìà Completezza: <strong>${Math.round((table.mappedFields/table.totalFields)*100)}%</strong></div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            if (ignoredTables.length > 0) {
                html += `
                    <div class="bg-gray-50 border border-gray-200 p-4 rounded-lg mb-4">
                        <h4 class="font-bold text-gray-700 mb-2">‚ö™ Tabelle Ignorate (${ignoredTables.length})</h4>
                        <div class="flex flex-wrap gap-2">
                            ${ignoredTables.map(table => 
                                `<span class="bg-gray-200 text-gray-600 px-2 py-1 rounded text-xs">${table.name}</span>`
                            ).join('')}
                        </div>
                        <p class="text-xs text-gray-600 mt-2">
                            üí° Per includerle, torna indietro e carica i CSV corrispondenti
                        </p>
                    </div>
                `;
            }
            
            html += `
                <div class="bg-green-50 border border-green-200 p-4 rounded-lg">
                    <div class="flex justify-between items-center">
                        <div>
                            <h4 class="font-bold text-green-700">Totale Elaborazione</h4>
                            <p class="text-green-600">
                                <strong>${totalRecords}</strong> record totali ‚Ä¢ 
                                <strong>${activeTableCount}</strong> tabelle attive ‚Ä¢ 
                                Modalit√† <strong>Mega-Batch Selettivo</strong>
                            </p>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-bold text-green-600">${totalRecords}</div>
                            <div class="text-sm text-green-500">Record Attivi</div>
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
            
            // Enable compile button only if there are active tables
            document.getElementById('compileBtn').disabled = activeTableCount === 0;
        }

        // =============================================
        // MEGA-BATCH COMPILATION
        // =============================================
        document.getElementById('compileBtn').addEventListener('click', async () => {
            const btn = document.getElementById('compileBtn');
            btn.disabled = true;
            btn.textContent = '‚è≥ Compilazione in corso...';
            
            document.getElementById('processProgress').classList.remove('hidden');
            state.processingStartTime = Date.now();
            
            try {
                await executeMultiTableMegaBatch();
                
                btn.textContent = '‚úÖ Compilazione selettiva completata';
                btn.style.background = '#10b981';
                
            } catch (error) {
                log(`‚ùå Errore compilazione: ${error.message}`, 'error');
                btn.disabled = false;
                btn.textContent = 'üöÄ COMPILA PDF SELETTIVO';
                btn.style.background = '#f97316';
                document.getElementById('processProgress').classList.add('hidden');
            }
        });

        async function executeMultiTableMegaBatch() {
            log('üöÄ AVVIO MEGA-BATCH MULTI-TABELLA...', 'api');
            
            updateProgress(10, 'Generazione XML multi-tabella...', 'Unificazione di tutte le tabelle');
            
            // Generate unified XML with all tables
            const xmlData = generateMultiTableXML();
            
            updateProgress(40, 'XML unificato generato', `Dimensione: ${Math.round(xmlData.length / 1024)}KB`);
            
            const form = new FormData();
            form.append('id', state.pdfResourceId);
            
            const dataBlob = new Blob([xmlData], { type: 'application/xml' });
            const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,'-');
            form.append('data_file', dataBlob, `multitable_${timestamp}.xml`);
            form.append('output', `pdf_multitable_${timestamp}`);
            
            updateProgress(60, 'Invio mega-batch multi-tabella...', 'Elaborazione server-side');
            
            log('üöÄ Invio MEGA-BATCH MULTI-TABELLA...', 'api');
            
            try {
                const response = await fetch(`${API_BASE}/pdf-with-imported-form-data`, {
                    method: 'POST',
                    body: form,
                    signal: AbortSignal.timeout(60000) // 60s per multi-tabella
                });
                
                if (!response.ok) {
                    throw new Error(`Mega-batch error: ${response.status}`);
                }
                
                const data = await response.json();
                state.compiledPdfUrl = data.outputUrl;
                
                const elapsedTime = Math.round((Date.now() - state.processingStartTime) / 1000);
                updateProgress(100, 'MEGA-BATCH COMPLETATO!', `Elaborazione completata in ${elapsedTime}s`);
                
                log('‚úÖ MEGA-BATCH MULTI-TABELLA SUCCESS! üéâ', 'success');
                
                showResults();
                
            } catch (error) {
                // Auto-fallback for multi-table
                log('‚ö†Ô∏è Proxy fallito, attivazione fallback multi-tabella...', 'warn');
                await executeMultiTableFallback(xmlData);
            }
        }

        function generateMultiTableXML() {
            log('üîß Generazione XML multi-tabella intelligente...', 'info');
            
            let xmlData = '<?xml version="1.0" encoding="UTF-8"?>\n';
            
            // Determina il namespace principale dalla struttura estratta
            if (state.pdfStructure.includes('xmlns=')) {
                const nsMatch = state.pdfStructure.match(/xmlns="([^"]+)"/);
                if (nsMatch) {
                    xmlData += `<root xmlns="${nsMatch[1]}">\n`;
                } else {
                    xmlData += '<root>\n';
                }
            } else {
                xmlData += '<root>\n';
            }
            
            // ‚úÖ NOVIT√Ä: Processa solo tabelle con CSV E mapping
            const activeTables = [];
            let totalProcessedRecords = 0;
            
            state.discoveredTables.forEach(table => {
                const csvData = state.csvData[table.id];
                const mapping = state.mappings[table.id];
                
                // Verifica che abbia sia CSV che mapping valido
                if (csvData && csvData.length > 0 && mapping && Object.values(mapping).some(v => v)) {
                    activeTables.push(table);
                    
                    log(`üìä Processando tabella: ${table.name} (${csvData.length} record)`, 'info');
                    
                    csvData.forEach((record, index) => {
                        xmlData += `  <${table.id}>\n`;
                        
                        // Mappa i campi CSV ai campi PDF
                        Object.entries(mapping).forEach(([csvField, pdfField]) => {
                            if (pdfField && record[csvField] !== undefined) {
                                const value = record[csvField] || '';
                                const escapedValue = value.replace(/[&<>"']/g, (char) => {
                                    const escapeMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&apos;' };
                                    return escapeMap[char];
                                });
                                xmlData += `    <${pdfField}>${escapedValue}</${pdfField}>\n`;
                            }
                        });
                        
                        xmlData += `  </${table.id}>\n`;
                        totalProcessedRecords++;
                        
                        // Progress update ogni 25 record
                        if (index % 25 === 0 && index > 0) {
                            updateProgress(20 + (index / csvData.length) * 15, 
                                         `Processando ${table.name}: ${index}/${csvData.length}`, 
                                         `Tabella ${activeTables.indexOf(table) + 1}/${activeTables.length}`);
                        }
                    });
                    
                    log(`‚úÖ Tabella ${table.name} completata: ${csvData.length} record`, 'success');
                } else {
                    log(`‚ö™ Tabella ${table.name} ignorata (no CSV o mapping)`, 'info');
                }
            });
            
            xmlData += '</root>';
            
            log(`‚úÖ XML selettivo generato: ${totalProcessedRecords} record da ${activeTables.length} tabelle attive`, 'success');
            log(`üìä Tabelle processate: ${activeTables.map(t => t.name).join(', ')}`, 'info');
            log(`üìè Dimensione finale: ${Math.round(xmlData.length / 1024)}KB`, 'info');
            
            return xmlData;
        }

        async function executeMultiTableFallback(xmlData) {
            log('üîÑ FALLBACK MULTI-TABELLA...', 'warn');
            
            updateProgress(70, 'Fallback: Chiamata diretta...', 'Bypass Netlify timeout');
            
            const form = new FormData();
            form.append('id', state.pdfResourceId);
            const dataBlob = new Blob([xmlData], { type: 'application/xml' });
            form.append('data_file', dataBlob, 'multitable_fallback.xml');
            form.append('output', 'pdf_multitable_fallback');
            
            const response = await fetch('https://api.pdfrest.com/pdf-with-imported-form-data', {
                method: 'POST',
                headers: { 'Api-Key': state.apiKey },
                body: form,
                signal: AbortSignal.timeout(90000)
            });
            
            if (!response.ok) {
                throw new Error(`Fallback failed: ${response.status}`);
            }
            
            const data = await response.json();
            state.compiledPdfUrl = data.outputUrl;
            
            const elapsedTime = Math.round((Date.now() - state.processingStartTime) / 1000);
            updateProgress(100, 'FALLBACK COMPLETATO!', `Multi-tabella in ${elapsedTime}s`);
            
            log('‚úÖ FALLBACK MULTI-TABELLA SUCCESS!', 'success');
            showResults();
        }

        function showResults() {
            const section = document.getElementById('resultsSection');
            const content = document.getElementById('resultsContent');
            
            // ‚úÖ NOVIT√Ä: Calcola solo tabelle attive
            const activeTables = state.discoveredTables.filter(table => 
                state.csvData[table.id] && state.csvData[table.id].length > 0 && 
                state.mappings[table.id] && Object.values(state.mappings[table.id]).some(v => v)
            );
            const totalRecords = activeTables.reduce((sum, table) => sum + state.csvData[table.id].length, 0);
            const elapsedTime = Math.round((Date.now() - state.processingStartTime) / 1000);
            
            let html = '<div class="text-center space-y-6">';
            html += '<h3 class="text-2xl font-bold text-green-600">üéâ PDF Selettivo Compilato!</h3>';
            html += '<p class="text-green-700">Compilazione intelligente completata con successo</p>';
            
            html += '<div class="grid grid-cols-1 md:grid-cols-4 gap-4 my-6">';
            html += `<div class="bg-green-50 p-4 rounded-lg">
                        <div class="text-2xl font-bold text-green-600">${activeTables.length}</div>
                        <div class="text-sm text-gray-600">Tabelle processate</div>
                     </div>`;
            html += `<div class="bg-blue-50 p-4 rounded-lg">
                        <div class="text-2xl font-bold text-blue-600">${totalRecords}</div>
                        <div class="text-sm text-gray-600">Record compilati</div>
                     </div>`;
            html += `<div class="bg-purple-50 p-4 rounded-lg">
                        <div class="text-2xl font-bold text-purple-600">${elapsedTime}s</div>
                        <div class="text-sm text-gray-600">Tempo elaborazione</div>
                     </div>`;
            html += `<div class="bg-orange-50 p-4 rounded-lg">
                        <div class="text-2xl font-bold text-orange-600">${Math.round(totalRecords/elapsedTime)}/s</div>
                        <div class="text-sm text-gray-600">Record al secondo</div>
                     </div>`;
            html += '</div>';
            
            // ‚úÖ DETTAGLI COMPILAZIONE
            if (activeTables.length > 0) {
                html += '<div class="bg-green-50 border border-green-200 p-4 rounded-lg mb-4">';
                html += '<h4 class="font-bold text-green-700 mb-2">‚úÖ Tabelle Compilate</h4>';
                html += '<div class="grid grid-cols-1 md:grid-cols-3 gap-2">';
                activeTables.forEach(table => {
                    const records = state.csvData[table.id].length;
                    html += `<div class="bg-white p-2 rounded text-sm">
                                <strong>${table.name}</strong><br>
                                <span class="text-green-600">${records} record</span>
                             </div>`;
                });
                html += '</div></div>';
            }
            
            // ‚úÖ TABELLE IGNORATE
            const ignoredTables = state.discoveredTables.filter(table => !activeTables.includes(table));
            if (ignoredTables.length > 0) {
                html += '<div class="bg-gray-50 border border-gray-200 p-4 rounded-lg mb-4">';
                html += `<h4 class="font-bold text-gray-700 mb-2">‚ö™ Tabelle Ignorate (${ignoredTables.length})</h4>`;
                html += '<div class="flex flex-wrap gap-2">';
                ignoredTables.forEach(table => {
                    html += `<span class="bg-gray-200 text-gray-600 px-2 py-1 rounded text-xs">${table.name}</span>`;
                });
                html += '</div>';
                html += '<p class="text-xs text-gray-600 mt-2">Non processate per mancanza di CSV o mapping</p>';
                html += '</div>';
            }
            
            if (state.compiledPdfUrl) {
                html += `<a href="${state.compiledPdfUrl}" target="_blank" 
                           class="btn btn-green inline-block text-lg px-8 py-4">
                           üì• SCARICA PDF SELETTIVO
                         </a>`;
            }
            
            html += '</div>';
            content.innerHTML = html;
            section.classList.remove('hidden');
        }

        // =============================================
        // RESET & UTILITY FUNCTIONS
        // =============================================
        document.getElementById('resetBtn').addEventListener('click', () => {
            if (confirm('Sei sicuro di voler ricominciare? Tutti i dati caricati andranno persi.')) {
                location.reload();
            }
        });

        // =============================================
        // EVENT LISTENERS & INITIALIZATION
        // =============================================
        document.getElementById('toggleKeyBtn').addEventListener('click', () => {
            const input = document.getElementById('apiKeyInput');
            input.type = input.type === 'password' ? 'text' : 'password';
        });

        document.getElementById('saveApiBtn').addEventListener('click', () => {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            if (!apiKey) {
                log('Inserisci l\'API key', 'error');
                return;
            }
            state.apiKey = apiKey;
            log('‚úÖ API key salvata!', 'success');
            document.getElementById('apiStatus').innerHTML = '<span class="status-ok">‚úÖ Configurato</span>';
        });

        document.getElementById('clearLogBtn').addEventListener('click', () => {
            document.getElementById('logArea').innerHTML = '';
            log('Log pulito', 'info');
        });

        // Initialize
        log('üîç PDF XFA Compiler Universale inizializzato', 'success');
        log('‚ú® Funzionalit√†: Auto-Discovery ‚Ä¢ Multi-Tabella ‚Ä¢ Mapping Dinamico ‚Ä¢ CSV Opzionali', 'info');
        state.apiKey = document.getElementById('apiKeyInput').value.trim();
    </script>

</body>
</html>

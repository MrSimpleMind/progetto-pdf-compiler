<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compilatore PDF XFA - ATS Monza Brianza (con Proxy)</title>
    <!-- === CORREZIONE 1: Link corretto a TailwindCSS === -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        .log-area {
            background: #000;
            color: #00ff00;
            font-family: monospace;
            padding: 15px;
            border-radius: 8px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
        }
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }
        .btn:disabled {
            background: #ccc !important;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .btn-blue { background: #3b82f6; color: white; }
        .btn-green { background: #10b981; color: white; }
        .btn-purple { background: #8b5cf6; color: white; }
        .btn-red { background: #ef4444; color: white; }
        .status-ok { color: #10b981; }
        .status-error { color: #ef4444; }
        .progress-bar {
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="container mx-auto p-6 max-w-6xl">
        <!-- Header -->
        <div class="bg-gradient-to-r from-blue-600 to-green-600 text-white p-6 rounded-lg mb-6 text-center">
            <h1 class="text-3xl font-bold mb-2">üìã Compilatore PDF XFA</h1>
            <p class="opacity-90">Compila automaticamente la tabella del personale nel PDF XFA</p>
        </div>

        <!-- Instructions -->
        <div class="bg-blue-50 border border-blue-200 p-6 rounded-lg mb-6">
            <h2 class="text-lg font-bold text-blue-700 mb-3">‚ÑπÔ∏è Come funziona</h2>
            <ol class="list-decimal list-inside space-y-2 text-sm">
                <li>Inserisci la tua API Key di pdfRest (verr√† usata tramite un proxy sicuro).</li>
                <li>Carica il file CSV con i dati del personale.</li>
                <li>Carica il PDF XFA da compilare.</li>
                <li>(Opzionale ma consigliato) Clicca "Analizza Campi PDF" per vedere i nomi dei campi.</li>
                <li>Clicca "Compila PDF XFA" per generare il file finale.</li>
            </ol>
        </div>

        <!-- API Configuration -->
        <div class="bg-white p-6 rounded-lg shadow mb-6">
            <h2 class="text-xl font-bold mb-4 text-blue-700">üîë Configurazione API pdfRest</h2>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div>
                    <label class="block text-sm font-bold mb-2">API Key:</label>
                    <div class="flex space-x-2">
                        <input 
                            type="password" 
                            id="apiKeyInput" 
                            placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
                            class="flex-1 p-3 border rounded font-mono text-sm"
                            value="bc95f9dc-d3e0-4b30-8da0-53f6deb83712"
                        >
                        <button id="toggleKeyBtn" class="btn btn-blue px-3">üëÅÔ∏è</button>
                    </div>
                    <div id="apiStatus" class="mt-2 text-sm"></div>
                </div>
                <div class="flex flex-col justify-end">
                    <button id="saveApiBtn" class="btn btn-green mb-2">üíæ Salva API Key</button>
                </div>
            </div>
        </div>

        <!-- File Upload -->
        <div class="bg-white p-6 rounded-lg shadow mb-6">
            <h2 class="text-xl font-bold mb-4 text-purple-700">üìÅ Caricamento File</h2>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="border-2 border-dashed border-green-400 rounded-lg p-6">
                    <div class="text-center mb-4">
                        <div class="text-4xl mb-2">üìä</div>
                        <h3 class="font-bold mb-2">File CSV Personale</h3>
                        <input type="file" id="csvFileInput" accept=".csv" class="hidden">
                        <button id="selectCSVBtn" class="btn btn-green">üìÇ Seleziona CSV</button>
                    </div>
                    <div id="csvStatus" class="text-sm mb-3"></div>
                    <div id="csvPreview" class="hidden bg-gray-50 p-3 rounded text-xs max-h-40 overflow-y-auto"></div>
                </div>
                <div class="border-2 border-dashed border-purple-400 rounded-lg p-6">
                    <div class="text-center mb-4">
                        <div class="text-4xl mb-2">üìÑ</div>
                        <h3 class="font-bold mb-2">PDF XFA ATS</h3>
                        <input type="file" id="pdfFileInput" accept=".pdf" class="hidden">
                        <button id="selectPDFBtn" class="btn btn-purple">üìÇ Seleziona PDF</button>
                    </div>
                    <div id="pdfStatus" class="text-sm mb-3"></div>
                </div>
            </div>
        </div>

        <!-- Process Control -->
        <div class="bg-white p-6 rounded-lg shadow mb-6">
            <h2 class="text-xl font-bold mb-4 text-green-700">üöÄ Azioni</h2>
            
            <!-- Page Selection -->
            <div class="mb-6 p-4 bg-blue-50 rounded-lg">
                <h3 class="font-bold text-blue-700 mb-3">üìÑ Selezione Pagine (Opzionale)</h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <label class="block text-sm font-bold mb-1">Pagina Inizio:</label>
                        <input type="number" id="startPageInput" min="1" max="100" value="4" 
                               class="w-full p-2 border rounded text-center">
                    </div>
                    <div>
                        <label class="block text-sm font-bold mb-1">Pagina Fine:</label>
                        <input type="number" id="endPageInput" min="1" max="100" value="6" 
                               class="w-full p-2 border rounded text-center">
                    </div>
                    <div class="flex items-end">
                        <button id="resetPagesBtn" class="btn btn-blue w-full text-sm">üîÑ Reset a Tutto</button>
                    </div>
                </div>
                <p class="text-xs text-gray-600 mt-2">üí° Lascia vuoto per processare tutto il PDF, oppure specifica l'intervallo di pagine con i moduli da compilare</p>
            </div>
            
            <div class="text-center mb-4 space-x-4">
                <button id="compileBtn" class="btn btn-purple text-lg px-8 py-4" disabled>
                    üöÄ Compila PDF XFA
                </button>
                <button id="debugBtn" class="btn btn-blue" disabled>üîç Analizza Campi PDF</button>
                <button id="exportBtn" class="btn btn-green" disabled>üì§ Esporta Struttura XFA</button>
                <p class="text-sm text-gray-600 mt-2" id="recordCount">In attesa dei file...</p>
            </div>
            <div id="processProgress" class="hidden mb-4">
                <div class="progress-bar mb-2">
                    <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                </div>
                <div id="progressText" class="text-center text-sm"></div>
            </div>
        </div>

        <!-- Results -->
        <div id="resultsSection" class="bg-white p-6 rounded-lg shadow mb-6 hidden">
            <h2 class="text-xl font-bold mb-4 text-green-700">‚úÖ PDF Compilato</h2>
            <div id="resultsContent"></div>
        </div>

        <!-- Log -->
        <div class="bg-white p-6 rounded-lg shadow">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-700">üìã Log Operazioni</h2>
                <button id="clearLogBtn" class="btn btn-red text-sm">üóëÔ∏è Pulisci</button>
            </div>
            <div id="logArea" class="log-area"></div>
        </div>
    </div>

    <script>
        // Global state
        const state = {
            apiKey: 'bc95f9dc-d3e0-4b30-8da0-53f6deb83712',
            csvData: null,
            pdfFile: null,
            pdfResourceId: null,
            compiledPdfUrl: null,
            selectedPages: { start: null, end: null },
            xfaStructure: null,  // ‚úÖ AGGIUNTO: Per memorizzare la struttura XFA estratta
            // ‚úÖ MAPPATURA CORRETTA: Nomi dei campi XFA reali estratti dalla struttura
            fieldMapping: {
                'COGNOME': 'cognome',
                'NOME': 'nome',
                'C.F.': 'codice_fiscale',
                'Qualifica (Q)': 'qualifica',
                'Tipo rapporto': 'rapporto_lavoro',
                'Tipo contratto (TC)': 'contratto_lavoro',
                'N. ore sett. Da contratto': 'n_ore_settimanali',
                'N. sett. Anno': 'n_settimane',
                'N. ore tot.': 'n_ore_totale',
                'di cui straordinari': 'n_ore_straordinarie'
            }
        };

        const API_BASE = '/api';

        function log(message, type = 'info') {
            const now = new Date().toLocaleTimeString();
            const colors = {
                'info': '#00ff00',
                'warn': '#ffff00', 
                'error': '#ff0000',
                'success': '#00ffff',
                'api': '#ff69b4'
            };
            const logArea = document.getElementById('logArea');
            const color = colors[type] || '#00ff00';
            logArea.innerHTML += `<div style="color: ${color};">[${now}] ${message}</div>`;
            logArea.scrollTop = logArea.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        document.getElementById('toggleKeyBtn').addEventListener('click', () => {
            const input = document.getElementById('apiKeyInput');
            input.type = input.type === 'password' ? 'text' : 'password';
        });

        document.getElementById('saveApiBtn').addEventListener('click', () => {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            if (!apiKey) {
                log('Inserisci l\'API key', 'error');
                return;
            }
            state.apiKey = apiKey;
            log('‚úÖ API key salvata!', 'success');
            document.getElementById('apiStatus').innerHTML = '<span class="status-ok">‚úÖ Configurato</span>';
            checkReadyState();
        });

        document.getElementById('debugBtn').addEventListener('click', getPdfInfo);
        document.getElementById('exportBtn').addEventListener('click', exportFormStructure);

        document.getElementById('selectCSVBtn').addEventListener('click', () => {
            document.getElementById('csvFileInput').click();
        });

        document.getElementById('csvFileInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            log('Caricamento CSV...', 'info');
            const reader = new FileReader();
            reader.onload = (e) => {
                Papa.parse(e.target.result, {
                    header: true,
                    delimiter: ";",
                    skipEmptyLines: true,
                    complete: (results) => {
                        state.csvData = results.data.filter(row => row['COGNOME'] && row['COGNOME'].trim());
                        log(`‚úÖ CSV caricato: ${state.csvData.length} record trovati`, 'success');
                        document.getElementById('csvStatus').innerHTML = `<span class="status-ok">‚úÖ ${state.csvData.length} record</span>`;
                        showCSVPreview();
                        updateRecordCount();
                        checkReadyState();
                    },
                    error: (error) => log(`‚ùå Errore parsing CSV: ${error.message}`, 'error')
                });
            };
            reader.readAsText(file, 'UTF-8');
        });

        function showCSVPreview() {
            const preview = document.getElementById('csvPreview');
            let html = '<table class="w-full text-xs">';
            html += '<thead><tr class="border-b">';
            Object.keys(state.fieldMapping).forEach(header => {
                html += `<th class="text-left p-1 text-[10px]">${header}</th>`;
            });
            html += '</tr></thead><tbody>';
            state.csvData.slice(0, 3).forEach((row) => {
                html += '<tr class="border-b">';
                Object.keys(state.fieldMapping).forEach(header => {
                    const value = row[header] || '';
                    html += `<td class="p-1 text-[10px]">${value.substring(0, 15)}${value.length > 15 ? '...' : ''}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table>';
            if (state.csvData.length > 3) {
                html += `<p class="text-center mt-2 text-gray-500">... e altri ${state.csvData.length - 3} record</p>`;
            }
            preview.innerHTML = html;
            preview.classList.remove('hidden');
        }

        document.getElementById('selectPDFBtn').addEventListener('click', () => {
            document.getElementById('pdfFileInput').click();
        });

        document.getElementById('pdfFileInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            if (file.type !== 'application/pdf') {
                log('‚ùå Il file deve essere un PDF', 'error');
                return;
            }
            state.pdfFile = file;
            state.pdfResourceId = null;
            const sizeMB = (file.size / 1024 / 1024).toFixed(2);
            log(`üìÑ PDF selezionato: ${file.name} (${sizeMB} MB)`, 'success');
            document.getElementById('pdfStatus').innerHTML = `<span class="status-ok">‚úÖ ${file.name}</span>`;
            checkReadyState();
        });

        function updateRecordCount() {
            if (state.csvData) {
                const batchSize = 10;
                const totalBatches = Math.ceil(state.csvData.length / batchSize);
                let message = `Pronti ${state.csvData.length} record (${totalBatches} batch da max ${batchSize}) per <personale_standard>`;
                document.getElementById('recordCount').textContent = message;
            }
        }

        function checkReadyState() {
            const ready = state.apiKey && state.csvData && state.pdfFile;
            const compileBtn = document.getElementById('compileBtn');
            const debugBtn = document.getElementById('debugBtn');
            compileBtn.disabled = !ready;
            // ‚úÖ CORREZIONE DEL BUG: era !!state.pdfFile (logica invertita)
            debugBtn.disabled = !state.pdfFile;  // Ora si abilita QUANDO c'√® un PDF
            document.getElementById('exportBtn').disabled = !state.pdfFile;  // Esporta struttura
            if (ready) {
                compileBtn.style.background = '#8b5cf6';
            }
        }

        document.getElementById('compileBtn').addEventListener('click', async () => {
            if (!state.apiKey || !state.csvData || !state.pdfFile) {
                log('‚ùå Mancano dei prerequisiti', 'error');
                return;
            }
            const btn = document.getElementById('compileBtn');
            btn.disabled = true;
            btn.textContent = '‚è≥ Compilazione in corso...';
            document.getElementById('processProgress').classList.remove('hidden');
            try {
                if (!state.pdfResourceId) {
                    updateProgress(20, 'Upload PDF...');
                    await uploadPDF();
                }
                updateProgress(50, 'Preparazione dati...');
                const formData = createFormData();
                updateProgress(70, 'Compilazione PDF...');
                await compilePDF(formData);
                updateProgress(100, 'Completato!');
                btn.textContent = '‚úÖ Compilazione completata';
                btn.style.background = '#10b981';
            } catch (error) {
                log(`‚ùå Errore: ${error.message}`, 'error');
                btn.disabled = false;
                btn.textContent = 'üöÄ Compila PDF XFA';
                document.getElementById('processProgress').classList.add('hidden');
            }
        });

        async function uploadPDF() {
            log('Upload PDF...', 'api');
            const formData = new FormData();
            formData.append('file', state.pdfFile);
            const response = await fetch(`${API_BASE}/upload`, {
                method: 'POST',
                body: formData
            });
            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Upload fallito: ${text}`);
            }
            const data = await response.json();
            state.pdfResourceId = data.files[0].id;
            log(`‚úÖ PDF uploadato. ID: ${state.pdfResourceId}`, 'success');
        }

        function createFormData() {
            log('üîß Preparazione dati per struttura XFA <personale_standard>...', 'info');
            
            // Log strategia sezioni logiche (non pagine fisiche)
            log('üìã XFA: Struttura logica, non basata su pagine fisiche', 'info');
            log('üéØ Target: Sezione <personale_standard> (tabella del personale)', 'info');
            
            const formData = {};
            
            // Per XFA usiamo la struttura corretta estratta
            state.csvData.forEach((record, index) => {
                Object.entries(state.fieldMapping).forEach(([csvField, xfaField]) => {
                    const value = record[csvField] || '';
                    // Per debug: formato campo[indice] (non pi√π usato, ma utile per log)
                    formData[`${xfaField}[${index}]`] = value;
                });
            });
            
            log(`‚úÖ Preparati ${state.csvData.length} elementi <personale_standard>`, 'success');
            log(`üìä Totale mapping: ${Object.keys(state.fieldMapping).length} campi per record`, 'info');
            
            return formData;
        }

        async function compilePDF(formData) {
            log('üîß Compilazione PDF XFA con BATCH PROCESSING...', 'api');
            
            // ‚úÖ SOLUZIONE: Batch da 10 record per evitare timeout
            const batchSize = 10;
            const totalBatches = Math.ceil(state.csvData.length / batchSize);
            
            log(`üìä Dividendo ${state.csvData.length} record in ${totalBatches} batch da ${batchSize}`, 'info');
            log('üéØ Modalit√† BATCH per evitare timeout', 'info');
            
            // Test con il primo batch
            const firstBatch = state.csvData.slice(0, batchSize);
            
            log(`üöÄ Processando primo batch: ${firstBatch.length} record`, 'api');
            
            // ‚úÖ STRUTTURA XFA CORRETTA per il batch
            let xmlData = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xmlData += '<welfare xmlns="http://schemas.sygest.it/adobe">\n';
            
            // Aggiungiamo ogni record del batch come elemento <personale_standard>
            firstBatch.forEach((record, index) => {
                xmlData += '  <personale_standard>\n';
                
                Object.entries(state.fieldMapping).forEach(([csvField, xfaField]) => {
                    const value = record[csvField] || '';
                    // Escape XML characters
                    const escapedValue = value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                    xmlData += `    <${xfaField}>${escapedValue}</${xfaField}>\n`;
                });
                
                // Aggiungiamo campi obbligatori con valori di default
                xmlData += '    <qualifica_altro/>\n';
                xmlData += '    <medico_responsabile>false</medico_responsabile>\n';
                xmlData += '    <contratto_lavoro_altro/>\n';
                xmlData += '    <setting_ria/>\n';
                xmlData += '    <n_ore_altri_ser_int/>\n';
                
                xmlData += '  </personale_standard>\n';
            });
            
            xmlData += '</welfare>';
            
            log(`üìã XML XFA generato per batch 1: ${firstBatch.length} elementi`, 'success');
            console.log('XML Batch Preview:', xmlData.substring(0, 800) + '...');
            
            const form = new FormData();
            form.append('id', state.pdfResourceId);
            
            // ‚úÖ RIMOZIONE async (non supportato)
            
            // Usa 'data_file' con formato XML corretto
            const dataBlob = new Blob([xmlData], { type: 'application/xml' });
            form.append('data_file', dataBlob, 'welfare_batch_1.xml');
            
            // Nome del file di output
            form.append('output', 'documento_batch_1');
            
            const response = await fetch(`${API_BASE}/pdf-with-imported-form-data`, {
                method: 'POST',
                body: form
            });
            
            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Compilazione batch fallita: ${text}`);
            }
            
            const data = await response.json();
            state.compiledPdfUrl = data.outputUrl;
            
            log('‚úÖ BATCH 1 completato con successo!', 'success');
            log(`üìã Record processati: ${firstBatch.length}/${state.csvData.length}`, 'info');
            
            if (totalBatches > 1) {
                log(`üîÑ PROSSIMI STEP: Implementare processamento batch 2-${totalBatches}`, 'info');
                log('üí° Per ora scarica il primo batch, poi processeremo il resto', 'info');
            }
            
            showResults();
        }
        


        function showResults() {
            const section = document.getElementById('resultsSection');
            const content = document.getElementById('resultsContent');
            let html = '<div class="text-center space-y-4">';
            html += '<p class="text-lg">Il PDF √® stato processato!</p>';
            html += '<p class="text-sm text-gray-600">Processati ' + state.csvData.length + ' record</p>';
            if (state.compiledPdfUrl) {
                html += `<a href="${state.compiledPdfUrl}" target="_blank" class="btn btn-green inline-block">üì• Scarica PDF Compilato</a>`;
            }
            html += '</div>';
            content.innerHTML = html;
            section.classList.remove('hidden');
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        document.getElementById('clearLogBtn').addEventListener('click', () => {
            document.getElementById('logArea').innerHTML = '';
            log('Log pulito', 'info');
        });

        // NUOVA FUNZIONE DI DEBUG
        async function getPdfInfo() {
            if (!state.pdfFile) {
                log('‚ùå Prima carica un PDF per analizzarlo!', 'error');
                return;
            }
            if (!state.pdfResourceId) {
                log('üî¨ Upload del PDF per l\'analisi in corso...', 'api');
                try {
                    await uploadPDF();
                } catch (e) {
                    log(`‚ùå Fallito l'upload per l'analisi: ${e.message}`, 'error');
                    return;
                }
            }

            log('üî¨ Richiesta informazioni sul PDF...', 'api');
            const form = new FormData();
            form.append('id', state.pdfResourceId);
            
            // === CORREZIONE: Usiamo query valide per verificare i tipi di modulo ===
            form.append('queries', 'contains_xfa,contains_acroforms,page_count,filename');

            try {
                const response = await fetch(`${API_BASE}/pdf-info`, {
                    method: 'POST',
                    body: form
                });

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`Analisi fallita: ${text}`);
                }

                const data = await response.json();
                
                log('‚úÖ INFORMAZIONI PDF RICEVUTE!', 'success');
                log('-------------------------------------------', 'success');
                console.log('Dati completi ricevuti da /pdf-info:', data);
                
                // ‚úÖ FIX: Controllo robusto per stringhe (gestisce anche valori censurati)
                const isXFA = String(data.contains_xfa).toLowerCase().includes('tr'); // 'true' o 'tr**'
                const isAcroForm = String(data.contains_acroforms).toLowerCase().includes('tr');
                
                if (isXFA) {
                    log('üìã ‚úÖ Il PDF contiene moduli XFA! Perfetto per la compilazione automatica.', 'success');
                } else if (isAcroForm) {
                    log('üìã ‚úÖ Il PDF contiene Acroforms! Compatibile per la compilazione.', 'success');
                } else {
                    log('‚ö†Ô∏è Il PDF non sembra contenere moduli compilabili standard', 'warn');
                    log('üí° Potrebbe essere un PDF statico o con moduli non standard', 'info');
                }
                
                log(`üìÑ Numero di pagine: ${data.page_count}`, 'info');
                log(`üìÅ Nome file: ${data.filename}`, 'info');
                log('-------------------------------------------', 'success');
                
                // ‚úÖ SUGGERIMENTI MIGLIORATI in base al tipo di modulo
                if (isXFA) {
                    log('üéØ STRATEGIA XFA AGGIORNATA:', 'success');
                    log('1Ô∏è‚É£ ‚úÖ Struttura XFA estratta e analizzata', 'info');
                    log('2Ô∏è‚É£ ‚úÖ Mapping dei campi aggiornato con nomi reali', 'info');
                    log('3Ô∏è‚É£ üöÄ PRONTO PER COMPILAZIONE: Usa "Compila PDF XFA"', 'info');
                    log('üìã Nota: XFA usa struttura logica, non pagine fisiche', 'info');
                    log('üéØ Compilazione mirata: Solo sezione <personale_standard>', 'info');
                } else if (isAcroForm) {
                    log('üéØ STRATEGIA CONSIGLIATA per Acroforms:', 'success');
                    log('1Ô∏è‚É£ Tenta la compilazione diretta', 'info');
                    log('2Ô∏è‚É£ Verifica il mapping dei nomi campi', 'info');
                } else {
                    log('‚ùì DIAGNOSI: Il PDF potrebbe non essere standard', 'warn');
                    log('üí° Prova comunque la compilazione - alcuni XFA complessi possono non essere rilevati correttamente', 'info');
                }

            } catch (error) {
                log(`‚ùå Errore durante l'analisi: ${error.message}`, 'error');
            }
        }
        
        // ‚úÖ NUOVA FUNZIONE: Esporta struttura XFA per capire il formato dati corretto
        async function exportFormStructure() {
            if (!state.pdfFile) {
                log('‚ùå Prima carica un PDF per estrarre la struttura!', 'error');
                return;
            }
            if (!state.pdfResourceId) {
                log('üì§ Upload del PDF per l\'estrazione in corso...', 'api');
                try {
                    await uploadPDF();
                } catch (e) {
                    log(`‚ùå Fallito l'upload per l'estrazione: ${e.message}`, 'error');
                    return;
                }
            }

            log('üì§ Estrazione struttura dati XFA...', 'api');
            const form = new FormData();
            form.append('id', state.pdfResourceId);
            
            // Per XFA usiamo formato XML
            form.append('data_format', 'xml');
            form.append('output', 'struttura_xfa');

            try {
                const response = await fetch(`${API_BASE}/exported-form-data`, {
                    method: 'POST',
                    body: form
                });

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`Estrazione fallita: ${text}`);
                }

                const data = await response.json();
                
                log('‚úÖ STRUTTURA XFA ESTRATTA!', 'success');
                log('-------------------------------------------', 'success');
                log('üìã URL del file di struttura XML:', 'success');
                log(data.outputUrl, 'info');
                log('-------------------------------------------', 'success');
                log('üí° PROSSIMI STEP:', 'success');
                log('1Ô∏è‚É£ Scarica il file XML dal link sopra', 'info');
                log('2Ô∏è‚É£ Analizza la struttura per capire i nomi dei campi corretti', 'info');
                log('3Ô∏è‚É£ Useremo quella struttura per generare dati compatibili', 'info');
                
                console.log('Dati completi dalla struttura XFA:', data);
                
                // Opzionalmente, proviamo a scaricare e mostrare la struttura
                if (data.outputUrl) {
                    try {
                        const xmlResponse = await fetch(data.outputUrl);
                        const xmlText = await xmlResponse.text();
                        log('üìã ANTEPRIMA STRUTTURA XML (primi 1000 caratteri):', 'success');
                        log(xmlText.substring(0, 1000) + '...', 'info');
                        console.log('Struttura XML completa:', xmlText);
                        
                        // Salviamo la struttura per usarla nella compilazione
                        state.xfaStructure = xmlText;
                        
                    } catch (e) {
                        log('‚ÑπÔ∏è Non riesco a scaricare automaticamente, usa il link sopra', 'warn');
                    }
                }

            } catch (error) {
                log(`‚ùå Errore durante l'estrazione: ${error.message}`, 'error');
            }
        }
        
        // ‚úÖ NUOVI LISTENER: Gestione selezione pagine
        document.getElementById('startPageInput').addEventListener('change', updatePageSelection);
        document.getElementById('endPageInput').addEventListener('change', updatePageSelection);
        document.getElementById('resetPagesBtn').addEventListener('click', () => {
            document.getElementById('startPageInput').value = '';
            document.getElementById('endPageInput').value = '';
            updatePageSelection();
        });
        
        function updatePageSelection() {
            const startPage = document.getElementById('startPageInput').value;
            const endPage = document.getElementById('endPageInput').value;
            
            state.selectedPages.start = startPage ? parseInt(startPage) : null;
            state.selectedPages.end = endPage ? parseInt(endPage) : null;
            
            if (state.selectedPages.start && state.selectedPages.end) {
                log(`üìÑ Selezione pagine: ${state.selectedPages.start}-${state.selectedPages.end}`, 'info');
            } else if (state.selectedPages.start) {
                log(`üìÑ Dalla pagina: ${state.selectedPages.start}`, 'info');
            } else if (state.selectedPages.end) {
                log(`üìÑ Fino alla pagina: ${state.selectedPages.end}`, 'info');
            } else {
                log('üìÑ Modalit√†: Tutto il PDF', 'info');
            }
        }
        
        // Initialize
        updatePageSelection(); // Imposta i valori di default (4-6)
        log('Sistema inizializzato', 'success');
    </script>

</body>
</html>
